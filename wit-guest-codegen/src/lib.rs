use std::{path::{Path, PathBuf}, fs::{self, File}, io::{self, BufWriter, Write}};

use wit_parser::Resolve;
use wit_bindgen_rust::Opts;

#[derive(Default, Clone)]
pub struct GenOptions {
    opts: Opts,
}

impl GenOptions {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn with_rustfmt(&mut self) -> &mut Self {
        self.opts.rustfmt = true;
        self
    }

    pub fn with_macro_prefix(&mut self, prefix: String) -> &mut Self {
        self.opts.macro_call_prefix = Some(prefix);
        self
    }

    pub fn with_macro_export(&mut self) -> &mut Self {
        self.opts.macro_export = true;
        self
    }

    pub fn with_export_macro_name(&mut self, name: String) -> &mut Self {
        self.opts.export_macro_name = Some(name);
        self
    }

    pub fn skip_functions(&mut self, funcs: Vec<String>) -> &mut Self {
        self.opts.skip = funcs;
        self
    }

    pub fn build<P: AsRef<Path>>(&mut self, wit_path: P) -> Generator {
        Generator::new(self.clone(), wit_path)
    }
}

pub struct Generator {
    options: GenOptions,
    wit_path: PathBuf,
}

impl Generator {
    pub fn new<P: AsRef<Path>>(options: GenOptions, wit_path: P) -> Self {
        Self { 
            options,
            wit_path: wit_path.as_ref().to_path_buf(),
        }
    }

    pub fn generate<S: AsRef<str>, P: AsRef<Path>>(&self, world: S, gen_folder: P) -> io::Result<()> {
        let gen_folder = gen_folder.as_ref();

        if !gen_folder.exists() {
            fs::create_dir(gen_folder)?;
        }
        let mut gen = self.options.opts.clone().build();

        let mut resolve = Resolve::default();
        let (pkg, _wit_files) = resolve.push_dir(&self.wit_path).unwrap();
        let world = resolve.select_world(pkg, Some(world.as_ref())).unwrap();

        let mut files = Default::default();
        gen.generate(&resolve, world, &mut files);
        let mut gen_files = Vec::new();
        for (s, src) in files.iter() {
            gen_files.push(s);
            let next_src_file = gen_folder.join(s);
    
            let mut f = File::create(next_src_file).unwrap();
            f.write_all(src).unwrap();
        }
        let mod_file = gen_files
            .into_iter()
            .map(|module| {
                let stripped = module.strip_suffix(".rs").unwrap();
                format!("pub mod {stripped};")
            })
            .collect::<Vec<String>>()
            .join("\n");
        let mut f = BufWriter::new(File::create(gen_folder.join("mod.rs"))?);
        writeln!(f, "// DO NOT EDIT!!!")?;
        writeln!(f, "// This file automatically generated by {} version {}\n", env!("CARGO_PKG_NAME"), env!("CARGO_PKG_VERSION"))?;
        f.write_all(mod_file.as_bytes())?;
        Ok(())
    }
}